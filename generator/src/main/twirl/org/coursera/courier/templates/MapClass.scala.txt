@(map: org.coursera.courier.generator.specs.MapDefinition)
@import java.util.Calendar
@import com.linkedin.data.schema.SchemaToJsonEncoder
@import com.linkedin.data.schema.JsonBuilder
@import org.coursera.courier.generator.specs._

@@Generated(value = Array("@(map.scalaType)"), comments="Courier Data Template.", date = "@(Calendar.getInstance().getTime())")
final class @(map.scalaType)(private val dataMap: DataMap)
  extends immutable.Iterable[(String, @(map.valueClass.scalaTypeFullname))]
  with Map[String, @(map.valueClass.scalaTypeFullname)]
  with immutable.MapLike[String, @(map.valueClass.scalaTypeFullname), immutable.Map[String, @(map.valueClass.scalaTypeFullname)]]
  with DataTemplate[DataMap] {
  import @(map.scalaType)._

  // TODO(jbetz): Decide on caching policy for data template types. We should not be creating a
  // new instance here on each lookup.
  private[this] def lookup(key: String): Option[@(map.valueClass.scalaTypeFullname)] = {
    @map.valueClass match {
      case recordItem: RecordDefinition => {
        Option(dataMap.getDataMap(key)).map(dataMap => @(map.valueClass.scalaTypeFullname)(dataMap, DataConversion.SetReadOnly))
      }
      case primitiveItem: PrimitiveDefinition => {
        Option(dataMap.get(key).asInstanceOf[@(primitiveItem.dataType)])
      }
      case enumItem: EnumDefinition => {
        Option(dataMap.get(key).asInstanceOf[String]).map(@(enumItem.enumName).fromString)
      }
      case customItem: ClassDefinition => {
        Option(dataMap.get(key)).map(value => DataTemplateUtil.coerceOutput(value, classOf[@(map.valueClass.scalaTypeFullname)]))
      }
      case _: Any => { }
    }
    @* TODO: add array values *@
    @* TODO: add map values *@
    @* TODO: add union values *@
  }

  override def get(key: String): Option[@(map.valueClass.scalaTypeFullname)] = lookup(key)

  override def iterator: Iterator[(String, @(map.valueClass.scalaTypeFullname))] = new Iterator[(String, @(map.valueClass.scalaTypeFullname))] {
    val underlying = dataMap.keySet().iterator()
    override def hasNext: Boolean = underlying.hasNext
    override def next(): (String, @(map.valueClass.scalaTypeFullname)) = {
      val key = underlying.next()
      key -> lookup(key).get
    }
  }

  override def +[F >: @(map.valueClass.scalaTypeFullname)](kv: (String, F)): Map[String, F] = {
    val (key, value) = kv
    value match {
      case v: @(map.valueClass.scalaTypeFullname) =>
        val copy = dataMap.copy()
        copy.put(key, coerceOutput(v))
        copy.setReadOnly()
        new @(map.scalaType)(copy)
      case _: Any =>
        (iterator ++ Iterator.single(kv)).toMap
    }
  }

  override def -(key: String): @(map.scalaType) = {
    val copy = dataMap.copy()
    copy.remove(key)
    copy.setReadOnly()
    new @(map.scalaType)(copy)
  }

  override def schema(): DataSchema = @(map.scalaType).SCHEMA

  override def data(): DataMap = dataMap

  override def copy(): DataTemplate[DataMap] = {
    val copy = dataMap.copy()
    copy.setReadOnly()
    new @(map.scalaType)(copy)
  }
}

object @(map.scalaType) {
  val SCHEMA = DataTemplateUtil.parseSchema(@("\"\"\"" + SchemaToJsonEncoder.schemaToJson(map.schema, JsonBuilder.Pretty.COMPACT) + "\"\"\"")).asInstanceOf[MapDataSchema]

  @* Register custom types and coercers. *@
  @map.customInfo.map { customInfo =>
    Custom.initializeCustomClass(classOf[@(customInfo.customClass.scalaTypeFullname)])
    @customInfo.coercerClass.map { coercer =>
      @(coercer.scalaTypeFullname).registerCoercer()
    }
  }

  val empty = @(map.scalaType)()

  def apply(elems: (String, @(map.valueClass.scalaTypeFullname))*): @(map.scalaType) = {
    @(map.scalaType)(elems.toMap)
  }

  def apply(map: Map[String, @(map.valueClass.scalaTypeFullname)]): @(map.scalaType) = {
    new @(map.scalaType)(new DataMap(map.mapValues(coerceOutput).asJava))
  }

  def apply(dataMap: DataMap, conversion: DataConversion): @(map.scalaType) = {
    new @(map.scalaType)(DataTemplates.makeImmutable(dataMap, SCHEMA, conversion))
  }

  def newBuilder = new DataBuilder()

  implicit val canBuildFrom = new CanBuildFrom[@(map.scalaType), (String, @(map.valueClass.scalaTypeFullname)), @(map.scalaType)] {
    def apply(from: @(map.scalaType)) = new DataBuilder(from)
    def apply() = newBuilder
  }

  class DataBuilder(initial: @(map.scalaType)) extends mutable.Builder[(String, @(map.valueClass.scalaTypeFullname)), @(map.scalaType)] {
    def this() = this(new @(map.scalaType)(new DataMap()))

    val entries = new DataMap(initial.data())

    def +=(kv: (String, @(map.valueClass.scalaTypeFullname))): this.type = {
      val (key, value) = kv
      entries.put(key, coerceOutput(value))
      this
    }

    def clear() = {
      entries.clear()
    }

    def result() = {
      entries.setReadOnly()
      new @(map.scalaType)(entries)
    }
  }

  private def coerceOutput(value: @(map.valueClass.scalaTypeFullname)): AnyRef = {
    @map.valueClass match {
      case recordItem: RecordDefinition => {
        value.data()
      }
      case primitiveItem: PrimitiveDefinition => {
        @primitiveItem.maybeBox{value}
      }
      case enumItem: EnumDefinition => {
        value.toString
      }
      case customItem: ClassDefinition => {
        DataTemplateUtil.coerceInput(value, classOf[@(map.valueClass.scalaTypeFullname)], classOf[@(map.valueDataClass.get.scalaTypeFullname)])
      }
      case _: Any => { }
    }
    @* TODO: add array values *@
    @* TODO: add map values *@
    @* TODO: add union values *@
  }
}
