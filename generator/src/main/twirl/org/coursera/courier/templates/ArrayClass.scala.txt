@(array: org.coursera.courier.generator.twirl.defs.ArrayDefinition)
@import java.util.Calendar
@import com.linkedin.data.schema.SchemaToJsonEncoder
@import com.linkedin.data.schema.JsonBuilder
@import org.coursera.courier.generator.twirl.defs._

@@Generated(value = Array("@(array.scalaType)"), comments="Courier Data Template.", date = "@(Calendar.getInstance().getTime())")
final class @(array.scalaType)(private val dataList: DataList)
  extends IndexedSeq[@(array.itemClass.dataType)]
  with Product
  with GenTraversable[@(array.itemClass.dataType)]
  with DataTemplate[DataList] {

  override def length: Int = dataList.size()

  @* TODO(jbetz): Decide on caching policy for data template types. We should not be creating a
   new instance here on each lookup. *@
  private[this] def lookup(idx: Int) = {
    @(array.itemClass.dataType)(dataList.get(idx).asInstanceOf[DataMap], DataTemplates.DataConversion.SetReadOnly)
  }

  override def apply(idx: Int): @(array.itemClass.dataType) = lookup(idx)

  override def productElement(n: Int): Any = dataList.get(n)
  override def productArity: Int = dataList.size()

  override def schema(): DataSchema = @(array.scalaType).SCHEMA

  override def data(): DataList = dataList
  override def copy(): DataTemplate[DataList] = this
}

object @(array.scalaType) {
  val SCHEMA = DataTemplateUtil.parseSchema(@("\"\"\"" + SchemaToJsonEncoder.schemaToJson(array.schema, JsonBuilder.Pretty.COMPACT) + "\"\"\"")).asInstanceOf[ArrayDataSchema]

  val empty = @(array.scalaType)()

  def apply(elems: @(array.itemClass.dataType)*): @(array.scalaType) = {
    new @(array.scalaType)(new DataList(elems.map(_.data()).toList.asJava))
  }

  def apply(collection: Traversable[@(array.itemClass.dataType)]): @(array.scalaType) = {
    new @(array.scalaType)(new DataList(collection.map(_.data()).toList.asJava))
  }

  def apply(dataList: DataList, conversion: DataConversion) : @(array.scalaType) = {
    new @(array.scalaType)(DataTemplates.makeImmutable(dataList, SCHEMA, conversion))
  }

  def newBuilder = new DataBuilder()

  implicit val canBuildFrom = new CanBuildFrom[@(array.scalaType), @(array.itemClass.dataType), @(array.scalaType)] {
    def apply(from: @(array.scalaType)) = new DataBuilder(from)
    def apply() = newBuilder
  }

  class DataBuilder(initial: @(array.scalaType)) extends mutable.Builder[@(array.itemClass.dataType), @(array.scalaType)] {
    def this() = this(new @(array.scalaType)(new DataList()))

    val elems = new DataList(initial.dataList)

    def +=(x: @(array.itemClass.dataType)): this.type = {
      elems.add(x.data())
      this
    }

    def clear() = {
      elems.clear()
    }

    def result() = {
      elems.setReadOnly()
      new @(array.scalaType)(elems)
    }
  }
}

