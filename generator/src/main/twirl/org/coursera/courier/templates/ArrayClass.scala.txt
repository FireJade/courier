@(array: org.coursera.courier.generator.twirl.defs.ArrayDefinition)
@import java.util.Calendar
@import com.linkedin.data.schema.SchemaToJsonEncoder
@import com.linkedin.data.schema.JsonBuilder
@import org.coursera.courier.generator.twirl.defs._

@@Generated(value = Array("@(array.scalaType)"), comments="Courier Data Template.", date = "@(Calendar.getInstance().getTime())")
final class @(array.scalaType)(private val dataList: DataList)
  extends IndexedSeq[@(array.itemClass.fqn)]
  with Product
  with GenTraversable[@(array.itemClass.fqn)]
  with DataTemplate[DataList] {

  override def length: Int = dataList.size()

  @* TODO(jbetz): Decide on caching policy for data template types. We should not be creating a
   new instance here on each lookup. *@
  private[this] def lookup(idx: Int) = {
    @array.itemClass match {
      case recordItem: RecordDefinition => {
        @(array.itemClass.fqn)(dataList.get(idx).asInstanceOf[DataMap], DataTemplates.DataConversion.SetReadOnly)
      }
      case primitiveItem: PrimitiveDefinition => {
        dataList.get(idx).asInstanceOf[@(primitiveItem.dataType)]
      }
      case enumItem: EnumDefinition => {
        @(enumItem.enumName).fromString(dataList.get(idx).asInstanceOf[String])
      }
      case customItem: ClassDefinition => {
        DataTemplateUtil.coerceOutput(dataList.get(idx), classOf[@(array.itemClass.fqn)])
      }
      case _: Any => { ??? }
    }
    @* TODO: add array items *@
    @* TODO: add map items *@
    @* TODO: add union items *@
  }

  override def apply(idx: Int): @(array.itemClass.fqn) = lookup(idx)

  override def productElement(n: Int): Any = dataList.get(n)
  override def productArity: Int = dataList.size()

  override def schema(): DataSchema = @(array.scalaType).SCHEMA

  override def data(): DataList = dataList
  override def copy(): DataTemplate[DataList] = this
}

object @(array.scalaType) {
  val SCHEMA = DataTemplateUtil.parseSchema(@("\"\"\"" + SchemaToJsonEncoder.schemaToJson(array.schema, JsonBuilder.Pretty.COMPACT) + "\"\"\"")).asInstanceOf[ArrayDataSchema]

  val empty = @(array.scalaType)()

  def apply(elems: @(array.itemClass.fqn)*): @(array.scalaType) = {
    new @(array.scalaType)(new DataList(elems.map(coerceOutput).toList.asJava))
  }

  def apply(collection: Traversable[@(array.itemClass.fqn)]): @(array.scalaType) = {
    new @(array.scalaType)(new DataList(collection.map(coerceOutput).toList.asJava))
  }

  def apply(dataList: DataList, conversion: DataConversion): @(array.scalaType) = {
    new @(array.scalaType)(DataTemplates.makeImmutable(dataList, SCHEMA, conversion))
  }

  def newBuilder = new DataBuilder()

  implicit val canBuildFrom = new CanBuildFrom[@(array.scalaType), @(array.itemClass.fqn), @(array.scalaType)] {
    def apply(from: @(array.scalaType)) = new DataBuilder(from)
    def apply() = newBuilder
  }

  class DataBuilder(initial: @(array.scalaType)) extends mutable.Builder[@(array.itemClass.fqn), @(array.scalaType)] {
    def this() = this(new @(array.scalaType)(new DataList()))

    val elems = new DataList(initial.data())

    def +=(x: @(array.itemClass.fqn)): this.type = {
      elems.add(coerceOutput(x))
      this
    }

    def clear() = {
      elems.clear()
    }

    def result() = {
      elems.setReadOnly()
      new @(array.scalaType)(elems)
    }
  }

  private def coerceOutput(value: @(array.itemClass.fqn)): AnyRef = {
    @array.itemClass match {
      case recordItem: RecordDefinition => {
        value.data()
      }
      case primitiveItem: PrimitiveDefinition => {
        @primitiveItem.maybeBox{value}
      }
      case enumItem: EnumDefinition => {
        value.toString
      }
      case customItem: ClassDefinition => {
        DataTemplateUtil.coerceInput(value, classOf[@(array.itemClass.fqn)], classOf[@(array.itemDataClass.get.fqn)])
      }
      case _: Any => { ??? }
    }
    @* TODO: add array items *@
    @* TODO: add map items *@
    @* TODO: add union items *@
  }
}

